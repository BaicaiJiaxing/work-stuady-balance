
---
#### **一、 核心思想：从逻辑视图到物理分布的映射**

ShardingSphere 的精髓在于构建了一个**逻辑层**，让开发者像操作单库单表一样工作，而它在底层自动完成了到复杂**物理层**的映射。这个映射过程就是**分片路由**。

-   **逻辑视图**: 应用开发者看到的单一数据库和一组逻辑表（如 `water_client`）。
-   **物理分布**: 数据实际存储在多个独立的数据库实例（**分库**）上，并且每个库中的数据可能还被拆分到多张物理表（**分表**）中。
-   **分片路由**: ShardingSphere 作为“智能翻译官”，根据预设规则，将一条逻辑 SQL 翻译成在正确物理节点上执行的一或多条物理 SQL。


#### **二、 分片策略的双重维度：分库 (Database) vs. 分表 (Table)**

系统通常采用复合分片策略，路由决策需要分两步完成：

1.  **第一步：分库路由（决定数据去哪个“城市”）**
    -   **目的**: 将数据分散到不同的数据库实例上，以突破单库的性能瓶颈（如连接数、IOPS）。
    -   **依据**: 通常使用变化频率较低、具有高区分度的业务字段，如**行政区划代码 (`abode_code`)**、**用户ID的某一部分**等。
    -   **示例**: 在本系统中，**`abode_code` 是核心的分库键**。`'05'` 对应 `ds_cy`（朝阳库），`'20'` 对应 `ds_sjs`（石景山库）。

2.  **第二步：分表路由（决定数据去哪条“街道”）**
    -   **目的**: 将单个库内的数据再次打散到多张物理表中，以减轻单表的读写压力和索引大小。
    -   **依据**: 通常使用数据量最大、查询最频繁的实体ID，如**用户编号 (`client_code`)**、**订单ID**等。
    -   **示例**: 在本系统中，**`client_code` 是核心的分表键**。通过哈希算法 `abs(client_code.hashCode()) % table_count` 计算出表后缀，如 `account_charge_meter_18`。

**路由顺序**: ShardingSphere 总是**先分库，再分表**。确定了目标数据库后，再在该库内确定目标物理表。

---

#### **三、 路由场景深度剖析：从简单到复杂**

##### **场景1：高效的单分片路由 (Single Shard Routing)**

-   **触发条件**: 查询 SQL 的 `WHERE` 子句中**同时提供了分库键和分表键**。
-   **示例**: `SELECT * FROM account_charge_meter WHERE abode_code = '05' AND client_code = 'C12345';`
-   **路由过程**:
    1.  **分库**: `abode_code = '05'` -> 算法计算 -> **定位到 `ds_cy` 库**。
    2.  **分表**: `client_code = 'C12345'` -> 哈希算法计算 -> **定位到 `_18` 表**。
    3.  **最终目标**: `ds_cy.account_charge_meter_18`。
-   **性能**: **最高效**。路由路径唯一且明确，数据库只执行一次点查询。

##### **场景2：分库不分表的路由**

-   **触发条件**: `WHERE` 子句中只提供了**分库键**，但查询的表本身不分表，或查询条件中没有分表键。
-   **示例**: `SELECT * FROM sys_order WHERE abode_code = '05';` (`sys_order` 只分库)
-   **路由过程**:
    1.  **分库**: `abode_code = '05'` -> 算法计算 -> **定位到 `ds_cy` 库**。
    2.  **最终目标**: `ds_cy.sys_order`。
-   **性能**: **高效**。虽然可能返回多条数据，但查询只落在一个物理库上。

##### **场景3：广播路由 (Broadcast Routing) - 性能陷阱**

-   **触发条件**: `WHERE` 子句中**既没有分库键，也没有分表键**。
-   **示例**: `SELECT * FROM account_charge_meter WHERE create_time > '2023-01-01';`
-   **路由过程**:
    1.  **分库**: 无法确定目标库，因此需要**路由到所有分库** (`ds_sq`, `ds_cy`, ...)。
    2.  **分表**: 在每个分库内，也无法确定目标表，因此需要**路由到该库的所有分表** (`_0`, `_1`, ...)。
    3.  **最终目标**: 笛卡尔积组合的所有物理表，例如 `ds_sq.account_charge_meter_0` ... `ds_jy.account_charge_meter_31`。
-   **性能**: **灾难性**。引发全集群范围内的全表扫描。

---

#### **四、 生产级路由实践：应对复杂业务场景**

##### **1. `JOIN` 查询的路由：绑定表与数据共存**

-   **问题**: `JOIN` 的表如果分库策略不同，或分库后物理位置不同，将导致跨库 `JOIN`。
-   **解决方案**: **绑定表 (Binding Tables)**。
-   **核心思想**: 保证主表和子表使用**相同的分库键**和**分库算法**。
-   **实现方式**:
    1.  **数据冗余**: 在所有子表中冗余存储主表的分库键（如 `abode_code`）。
    2.  **配置绑定**: 在 ShardingSphere 中声明它们的绑定关系。
-   **路由效果**: 当 `JOIN` 查询带有分库键时，ShardingSphere 能**确信**所有关联数据都在同一个物理库中，从而将 `JOIN` 操作安全地**下推 (Push Down)** 到该数据库执行，实现高性能。

##### **2. 路由键异构的兼容性路由：自定义算法适配**

-   **问题**: 系统演进中，新旧分库键并存（如 `open_abode_code` vs `abode_code`）。
-   **解决方案**: 设计一个**兼容性的自定义分库算法**。
-   **核心思想**: 算法扮演“适配器”，抹平新旧分库键的差异。
-   **路由效果**: 即使 `JOIN` 的两张表使用了不同的分库键字段，算法也能保证将它们路由到**同一个物理库**，保障了平滑迁移过程中的 `JOIN` 性能。

##### **3. 更新/删除分片键的路由风险**

-   **问题**: 直接 `UPDATE` 分库键 (`abode_code`)，即使新旧值路由到同一个库，也会破坏数据共存性。且若 `WHERE` 子句不带旧分片键，会触发广播路由。
-   **正确路由方式**:
    -   `UPDATE` 的 `WHERE` 子句必须带上**旧的**分库键值，实现精准路由。
    -   **最佳实践**: 视作一次数据迁移，采用**“新增（带新分库键）+ 删除（带旧分库键）”** 的模式，并用事务包裹。

---

#### **五、 学习总结与关键启示**

1.  **分库是核心隔离**: 分库策略决定了数据的物理边界，是扩展性的基础。选择稳定且高区分度的字段作为分库键至关重要。
2.  **分表是库内优化**: 分表策略解决了单库内单表的性能问题。
3.  **`JOIN` 性能靠共存**: 高性能 `JOIN` 的前提是“数据共存”（Collocation），即关联数据必须在同一个物理库。绑定表是实现共存的利器。
4.  **算法是路由的大脑**: 自定义分片算法提供了极高的灵活性，可以解决平滑迁移、兼容异构等复杂路由问题。
5.  **日志是真相之眼**: 观察 ShardingSphere 打印的物理 SQL，是验证分库分表路由行为是否符合预期的最有效手段。明确看到SQL发往了预期的单个物理库，才算路由正确。

经验来源：[[2025-08-22]]